--- LVM2.2.02.72-RHEL6-edited2/daemons/clvmd/lvm-functions.c	2010-07-01 22:23:48.000000000 +0100
+++ LVM2.2.02.72-RHEL6-edited3/daemons/clvmd/lvm-functions.c	2010-08-18 03:40:48.000000000 +0100
@@ -350,12 +350,12 @@ static int do_activate_lv(char *resource
 	}
 
 	/* If it's suspended then resume it */
-	if (!lv_info_by_lvid(cmd, resource, &lvi, 0, 0))
+	if (!lv_info_by_lvid(cmd, resource, 0, &lvi, 0, 0))
 		goto error;
 
 	if (lvi.suspended) {
 		memlock_inc(cmd);
-		if (!lv_resume(cmd, resource)) {
+		if (!lv_resume(cmd, resource, 0)) {
 			memlock_dec(cmd);
 			goto error;
 		}
@@ -385,7 +385,7 @@ static int do_resume_lv(char *resource, 
 		return 0;	/* We don't need to do anything */
 	}
 
-	if (!lv_resume_if_active(cmd, resource))
+	if (!lv_resume_if_active(cmd, resource, 0))
 		return EIO;
 
 	return 0;
@@ -405,11 +405,11 @@ static int do_suspend_lv(char *resource,
 	}
 
 	/* Only suspend it if it exists */
-	if (!lv_info_by_lvid(cmd, resource, &lvi, 0, 0))
+	if (!lv_info_by_lvid(cmd, resource, 0, &lvi, 0, 0))
 		return EIO;
 
 	if (lvi.exists) {
-		if (!lv_suspend_if_active(cmd, resource)) {
+		if (!lv_suspend_if_active(cmd, resource, 0)) {
 			return EIO;
 		}
 	}
@@ -571,7 +571,7 @@ int post_lock_lv(unsigned char command, 
 			struct lvinfo lvi;
 
 			pthread_mutex_lock(&lvm_lock);
-			status = lv_info_by_lvid(cmd, resource, &lvi, 0, 0);
+			status = lv_info_by_lvid(cmd, resource, 0, &lvi, 0, 0);
 			pthread_mutex_unlock(&lvm_lock);
 			if (!status)
 				return EIO;
--- LVM2.2.02.72-RHEL6-edited2/lib/activate/activate.c	2010-08-18 02:48:28.000000000 +0100
+++ LVM2.2.02.72-RHEL6-edited3/lib/activate/activate.c	2010-08-18 03:40:48.000000000 +0100
@@ -146,12 +146,13 @@ int target_present(struct cmd_context *c
 {
 	return 0;
 }
-int lv_info(struct cmd_context *cmd, const struct logical_volume *lv, struct lvinfo *info,
-	    int with_open_count, int with_read_ahead)
+int lv_info(struct cmd_context *cmd, const struct logical_volume *lv, unsigned origin_only,
+	    struct lvinfo *info, int with_open_count, int with_read_ahead)
 {
 	return 0;
 }
 int lv_info_by_lvid(struct cmd_context *cmd, const char *lvid_s,
+		    unsigned origin_only,
 		    struct lvinfo *info, int with_open_count, int with_read_ahead)
 {
 	return 0;
@@ -175,10 +176,12 @@ int lvs_in_vg_opened(struct volume_group
 {
 	return 0;
 }
+/******
 int lv_suspend(struct cmd_context *cmd, const char *lvid_s)
 {
 	return 1;
 }
+*******/
 int lv_suspend_if_active(struct cmd_context *cmd, const char *lvid_s)
 {
 	return 1;
@@ -450,7 +453,7 @@ int target_present(struct cmd_context *c
 /*
  * Returns 1 if info structure populated, else 0 on failure.
  */
-int lv_info(struct cmd_context *cmd, const struct logical_volume *lv,
+int lv_info(struct cmd_context *cmd, const struct logical_volume *lv, unsigned origin_only,
 	    struct lvinfo *info, int with_open_count, int with_read_ahead)
 {
 	struct dm_info dminfo;
@@ -458,7 +461,7 @@ int lv_info(struct cmd_context *cmd, con
 	if (!activation())
 		return 0;
 
-	if (!dev_manager_info(lv->vg->cmd->mem, lv, with_open_count,
+	if (!dev_manager_info(lv->vg->cmd->mem, lv, origin_only ? "real" : NULL, with_open_count,
 			      with_read_ahead, &dminfo, &info->read_ahead))
 		return_0;
 
@@ -475,6 +478,7 @@ int lv_info(struct cmd_context *cmd, con
 }
 
 int lv_info_by_lvid(struct cmd_context *cmd, const char *lvid_s,
+		    unsigned origin_only,
 		    struct lvinfo *info, int with_open_count, int with_read_ahead)
 {
 	int r;
@@ -483,7 +487,10 @@ int lv_info_by_lvid(struct cmd_context *
 	if (!(lv = lv_from_lvid(cmd, lvid_s, 0)))
 		return 0;
 
-	r = lv_info(cmd, lv, info, with_open_count, with_read_ahead);
+	if (!lv_is_origin(lv))
+		origin_only = 0;
+
+	r = lv_info(cmd, lv, origin_only, info, with_open_count, with_read_ahead);
 	vg_release(lv->vg);
 
 	return r;
@@ -553,7 +560,7 @@ int lv_mirror_percent(struct cmd_context
 	if (!activation())
 		return 0;
 
-	if (!lv_info(cmd, lv, &info, 0, 0))
+	if (!lv_info(cmd, lv, 0, &info, 0, 0))
 		return_0;
 
 	if (!info.exists)
@@ -575,7 +582,7 @@ static int _lv_active(struct cmd_context
 {
 	struct lvinfo info;
 
-	if (!lv_info(cmd, lv, &info, 0, 0)) {
+	if (!lv_info(cmd, lv, 0, &info, 0, 0)) {
 		stack;
 		return -1;
 	}
@@ -587,7 +594,7 @@ static int _lv_open_count(struct cmd_con
 {
 	struct lvinfo info;
 
-	if (!lv_info(cmd, lv, &info, 1, 0)) {
+	if (!lv_info(cmd, lv, 0, &info, 1, 0)) {
 		stack;
 		return -1;
 	}
@@ -595,7 +602,7 @@ static int _lv_open_count(struct cmd_con
 	return info.open_count;
 }
 
-static int _lv_activate_lv(struct logical_volume *lv)
+static int _lv_activate_lv(struct logical_volume *lv, unsigned origin_only)
 {
 	int r;
 	struct dev_manager *dm;
@@ -603,14 +610,14 @@ static int _lv_activate_lv(struct logica
 	if (!(dm = dev_manager_create(lv->vg->cmd, lv->vg->name)))
 		return_0;
 
-	if (!(r = dev_manager_activate(dm, lv)))
+	if (!(r = dev_manager_activate(dm, lv, origin_only)))
 		stack;
 
 	dev_manager_destroy(dm);
 	return r;
 }
 
-static int _lv_preload(struct logical_volume *lv, int *flush_required)
+static int _lv_preload(struct logical_volume *lv, unsigned origin_only, int *flush_required)
 {
 	int r;
 	struct dev_manager *dm;
@@ -618,7 +625,7 @@ static int _lv_preload(struct logical_vo
 	if (!(dm = dev_manager_create(lv->vg->cmd, lv->vg->name)))
 		return_0;
 
-	if (!(r = dev_manager_preload(dm, lv, flush_required)))
+	if (!(r = dev_manager_preload(dm, lv, origin_only, flush_required)))
 		stack;
 
 	dev_manager_destroy(dm);
@@ -640,7 +647,7 @@ static int _lv_deactivate(struct logical
 	return r;
 }
 
-static int _lv_suspend_lv(struct logical_volume *lv, int lockfs, int flush_required)
+static int _lv_suspend_lv(struct logical_volume *lv, unsigned origin_only, int lockfs, int flush_required)
 {
 	int r;
 	struct dev_manager *dm;
@@ -648,7 +655,7 @@ static int _lv_suspend_lv(struct logical
 	if (!(dm = dev_manager_create(lv->vg->cmd, lv->vg->name)))
 		return_0;
 
-	if (!(r = dev_manager_suspend(dm, lv, lockfs, flush_required)))
+	if (!(r = dev_manager_suspend(dm, lv, origin_only, lockfs, flush_required)))
 		stack;
 
 	dev_manager_destroy(dm);
@@ -731,8 +738,8 @@ int lv_is_active(struct logical_volume *
  * Returns 0 if an attempt to (un)monitor the device failed.
  * Returns 1 otherwise.
  */
-int monitor_dev_for_events(struct cmd_context *cmd,
-			    struct logical_volume *lv, int monitor)
+int monitor_dev_for_events(struct cmd_context *cmd, struct logical_volume *lv,
+			   unsigned origin_only, int monitor)
 {
 #ifdef DMEVENTD
 	int i, pending = 0, monitored;
@@ -758,17 +765,17 @@ int monitor_dev_for_events(struct cmd_co
 	 * not the actual LV itself.
 	 */
 	if (lv_is_cow(lv) && !lv_is_merging_cow(lv))
-		return monitor_dev_for_events(cmd, lv->snapshot->lv, monitor);
+		return monitor_dev_for_events(cmd, lv->snapshot->lv, 0, monitor);
 
 	/*
 	 * In case this LV is a snapshot origin, we instead monitor
 	 * each of its respective snapshots.  The origin itself may
 	 * also need to be monitored if it is a mirror, for example.
 	 */
-	if (lv_is_origin(lv))
+	if (!origin_only && lv_is_origin(lv))
 		dm_list_iterate_safe(snh, snht, &lv->snapshot_segs)
 			if (!monitor_dev_for_events(cmd, dm_list_struct_base(snh,
-				    struct lv_segment, origin_list)->cow, monitor))
+				    struct lv_segment, origin_list)->cow, 0, monitor))
 				r = 0;
 
 	/*
@@ -778,7 +785,7 @@ int monitor_dev_for_events(struct cmd_co
 	if ((seg = first_seg(lv)) != NULL && seg->log_lv != NULL &&
 	    (log_seg = first_seg(seg->log_lv)) != NULL &&
 	    seg_is_mirrored(log_seg))
-		if (!monitor_dev_for_events(cmd, seg->log_lv, monitor))
+		if (!monitor_dev_for_events(cmd, seg->log_lv, 0, monitor))
 			r = 0;
 
 	dm_list_iterate(tmp, &lv->segments) {
@@ -788,7 +795,7 @@ int monitor_dev_for_events(struct cmd_co
 		for (s = 0; s < seg->area_count; s++) {
 			if (seg_type(seg, s) != AREA_LV)
 				continue;
-			if (!monitor_dev_for_events(cmd, seg_lv(seg, s),
+			if (!monitor_dev_for_events(cmd, seg_lv(seg, s), 0,
 						    monitor)) {
 				log_error("Failed to %smonitor %s",
 					  monitor ? "" : "un",
@@ -863,7 +870,7 @@ int monitor_dev_for_events(struct cmd_co
 }
 
 static int _lv_suspend(struct cmd_context *cmd, const char *lvid_s,
-		       int error_if_not_suspended)
+		       unsigned origin_only, int error_if_not_suspended)
 {
 	struct logical_volume *lv = NULL, *lv_pre = NULL;
 	struct lvinfo info;
@@ -879,13 +886,17 @@ static int _lv_suspend(struct cmd_contex
 	if (!(lv_pre = lv_from_lvid(cmd, lvid_s, 1)))
 		goto_out;
 
+	/* Ignore origin_only unless LV is origin in both old and new metadata */
+	if (!lv_is_origin(lv) || !lv_is_origin(lv_pre))
+		origin_only = 0;
+
 	if (test_mode()) {
-		_skip("Suspending '%s'.", lv->name);
+		_skip("Suspending %s%s.", lv->name, origin_only ? " origin without snapshots" : "");
 		r = 1;
 		goto out;
 	}
 
-	if (!lv_info(cmd, lv, &info, 0, 0))
+	if (!lv_info(cmd, lv, origin_only, &info, 0, 0))
 		goto_out;
 
 	if (!info.exists || info.suspended) {
@@ -904,22 +915,23 @@ static int _lv_suspend(struct cmd_contex
 
 	/* If VG was precommitted, preload devices for the LV */
 	if ((lv_pre->vg->status & PRECOMMITTED)) {
-		if (!_lv_preload(lv_pre, &flush_required)) {
+		if (!_lv_preload(lv_pre, origin_only, &flush_required)) {
 			/* FIXME Revert preloading */
 			goto_out;
 		}
 	}
 
-	if (!monitor_dev_for_events(cmd, lv, 0))
+	if (!monitor_dev_for_events(cmd, lv, origin_only, 0))
 		/* FIXME Consider aborting here */
 		stack;
 
 	memlock_inc(cmd);
 
-	if (lv_is_origin(lv_pre) || lv_is_cow(lv_pre))
+	if (!origin_only &&
+	    (lv_is_origin(lv_pre) || lv_is_cow(lv_pre)))
 		lockfs = 1;
 
-	if (!_lv_suspend_lv(lv, lockfs, flush_required)) {
+	if (!_lv_suspend_lv(lv, origin_only, lockfs, flush_required)) {
 		memlock_dec(cmd);
 		fs_unlock();
 		goto out;
@@ -938,17 +950,21 @@ out:
 }
 
 /* Returns success if the device is not active */
-int lv_suspend_if_active(struct cmd_context *cmd, const char *lvid_s)
+int lv_suspend_if_active(struct cmd_context *cmd, const char *lvid_s, unsigned origin_only)
 {
-	return _lv_suspend(cmd, lvid_s, 0);
+	return _lv_suspend(cmd, lvid_s, origin_only, 0);
 }
 
+/* No longer used */
+/***********
 int lv_suspend(struct cmd_context *cmd, const char *lvid_s)
 {
 	return _lv_suspend(cmd, lvid_s, 1);
 }
+***********/
 
 static int _lv_resume(struct cmd_context *cmd, const char *lvid_s,
+		      unsigned origin_only,
 		      int error_if_not_active)
 {
 	struct logical_volume *lv;
@@ -961,13 +977,16 @@ static int _lv_resume(struct cmd_context
 	if (!(lv = lv_from_lvid(cmd, lvid_s, 0)))
 		goto_out;
 
+	if (!lv_is_origin(lv))
+		origin_only = 0;
+
 	if (test_mode()) {
-		_skip("Resuming '%s'.", lv->name);
+		_skip("Resuming %s%s.", lv->name, origin_only ? " without snapshots" : "");
 		r = 1;
 		goto out;
 	}
 
-	if (!lv_info(cmd, lv, &info, 0, 0))
+	if (!lv_info(cmd, lv, origin_only, &info, 0, 0))
 		goto_out;
 
 	if (!info.exists || !info.suspended) {
@@ -977,13 +996,13 @@ static int _lv_resume(struct cmd_context
 		goto out;
 	}
 
-	if (!_lv_activate_lv(lv))
+	if (!_lv_activate_lv(lv, origin_only))
 		goto_out;
 
 	memlock_dec(cmd);
 	fs_unlock();
 
-	if (!monitor_dev_for_events(cmd, lv, 1))
+	if (!monitor_dev_for_events(cmd, lv, origin_only, 1))
 		stack;
 
 	r = 1;
@@ -995,14 +1014,14 @@ out:
 }
 
 /* Returns success if the device is not active */
-int lv_resume_if_active(struct cmd_context *cmd, const char *lvid_s)
+int lv_resume_if_active(struct cmd_context *cmd, const char *lvid_s, unsigned origin_only)
 {
-	return _lv_resume(cmd, lvid_s, 0);
+	return _lv_resume(cmd, lvid_s, origin_only, 0);
 }
 
-int lv_resume(struct cmd_context *cmd, const char *lvid_s)
+int lv_resume(struct cmd_context *cmd, const char *lvid_s, unsigned origin_only)
 {
-	return _lv_resume(cmd, lvid_s, 1);
+	return _lv_resume(cmd, lvid_s, origin_only, 1);
 }
 
 static int _lv_has_open_snapshots(struct logical_volume *lv)
@@ -1012,7 +1031,7 @@ static int _lv_has_open_snapshots(struct
 	int r = 0;
 
 	dm_list_iterate_items_gen(snap_seg, &lv->snapshot_segs, origin_list) {
-		if (!lv_info(lv->vg->cmd, snap_seg->cow, &info, 1, 0)) {
+		if (!lv_info(lv->vg->cmd, snap_seg->cow, 0, &info, 1, 0)) {
 			r = 1;
 			continue;
 		}
@@ -1046,7 +1065,7 @@ int lv_deactivate(struct cmd_context *cm
 		goto out;
 	}
 
-	if (!lv_info(cmd, lv, &info, 1, 0))
+	if (!lv_info(cmd, lv, 0, &info, 1, 0))
 		goto_out;
 
 	if (!info.exists) {
@@ -1069,7 +1088,7 @@ int lv_deactivate(struct cmd_context *cm
 
 	lv_calculate_readahead(lv, NULL);
 
-	if (!monitor_dev_for_events(cmd, lv, 0))
+	if (!monitor_dev_for_events(cmd, lv, 0, 0))
 		stack;
 
 	memlock_inc(cmd);
@@ -1077,7 +1096,7 @@ int lv_deactivate(struct cmd_context *cm
 	memlock_dec(cmd);
 	fs_unlock();
 
-	if (!lv_info(cmd, lv, &info, 1, 0) || info.exists)
+	if (!lv_info(cmd, lv, 0, &info, 1, 0) || info.exists)
 		r = 0;
 out:
 	if (lv) {
@@ -1154,7 +1173,7 @@ static int _lv_activate(struct cmd_conte
 		goto out;
 	}
 
-	if (!lv_info(cmd, lv, &info, 0, 0))
+	if (!lv_info(cmd, lv, 0, &info, 0, 0))
 		goto_out;
 
 	if (info.exists && !info.suspended && info.live_table) {
@@ -1171,12 +1190,12 @@ static int _lv_activate(struct cmd_conte
 		lv->status |= ACTIVATE_EXCL;
 
 	memlock_inc(cmd);
-	if (!(r = _lv_activate_lv(lv)))
+	if (!(r = _lv_activate_lv(lv, 0)))
 		stack;
 	memlock_dec(cmd);
 	fs_unlock();
 
-	if (r && !monitor_dev_for_events(cmd, lv, 1))
+	if (r && !monitor_dev_for_events(cmd, lv, 0, 1))
 		stack;
 
 out:
--- LVM2.2.02.72-RHEL6-edited2/lib/activate/activate.h	2010-05-24 16:32:20.000000000 +0100
+++ LVM2.2.02.72-RHEL6-edited3/lib/activate/activate.h	2010-08-18 03:40:48.000000000 +0100
@@ -53,10 +53,10 @@ int list_lv_modules(struct dm_pool *mem,
 void activation_release(void);
 void activation_exit(void);
 
-int lv_suspend(struct cmd_context *cmd, const char *lvid_s);
-int lv_suspend_if_active(struct cmd_context *cmd, const char *lvid_s);
-int lv_resume(struct cmd_context *cmd, const char *lvid_s);
-int lv_resume_if_active(struct cmd_context *cmd, const char *lvid_s);
+/* int lv_suspend(struct cmd_context *cmd, const char *lvid_s); */
+int lv_suspend_if_active(struct cmd_context *cmd, const char *lvid_s, unsigned origin_only);
+int lv_resume(struct cmd_context *cmd, const char *lvid_s, unsigned origin_only);
+int lv_resume_if_active(struct cmd_context *cmd, const char *lvid_s, unsigned origin_only);
 int lv_activate(struct cmd_context *cmd, const char *lvid_s, int exclusive);
 int lv_activate_with_filter(struct cmd_context *cmd, const char *lvid_s,
 			    int exclusive);
@@ -67,9 +67,10 @@ int lv_mknodes(struct cmd_context *cmd, 
 /*
  * Returns 1 if info structure has been populated, else 0.
  */
-int lv_info(struct cmd_context *cmd, const struct logical_volume *lv, struct lvinfo *info,
+int lv_info(struct cmd_context *cmd, const struct logical_volume *lv,
+	    unsigned origin_only, struct lvinfo *info,
 	    int with_open_count, int with_read_ahead);
-int lv_info_by_lvid(struct cmd_context *cmd, const char *lvid_s,
+int lv_info_by_lvid(struct cmd_context *cmd, const char *lvid_s, unsigned origin_only,
 		    struct lvinfo *info, int with_open_count, int with_read_ahead);
 
 /*
@@ -99,8 +100,8 @@ int lv_is_active(struct logical_volume *
 int lv_has_target_type(struct dm_pool *mem, struct logical_volume *lv,
 		       const char *layer, const char *target_type);
 
-int monitor_dev_for_events(struct cmd_context *cmd,
-			    struct logical_volume *lv, int do_reg);
+int monitor_dev_for_events(struct cmd_context *cmd, struct logical_volume *lv,
+			   unsigned origin_only, int do_reg);
 
 /*
  * Returns 1 if PV has a dependency tree that uses anything in VG.
--- LVM2.2.02.72-RHEL6-edited2/lib/activate/dev_manager.c	2010-08-18 02:48:46.000000000 +0100
+++ LVM2.2.02.72-RHEL6-edited3/lib/activate/dev_manager.c	2010-08-18 03:40:48.000000000 +0100
@@ -222,18 +222,19 @@ static int _info_by_dev(uint32_t major, 
 }
 
 int dev_manager_info(struct dm_pool *mem, const struct logical_volume *lv,
+		     const char *layer,
 		     int with_open_count, int with_read_ahead,
 		     struct dm_info *info, uint32_t *read_ahead)
 {
-	const char *dlid, *name;
+	char *dlid, *name;
 	int r;
 
-	if (!(name = build_dm_name(mem, lv->vg->name, lv->name, NULL))) {
+	if (!(name = build_dm_name(mem, lv->vg->name, lv->name, layer))) {
 		log_error("name build failed for %s", lv->name);
 		return 0;
 	}
 
-	if (!(dlid = build_dm_uuid(mem, lv->lvid.s, NULL))) {
+	if (!(dlid = build_dm_uuid(mem, lv->lvid.s, layer))) {
 		log_error("dlid build failed for %s", lv->name);
 		return 0;
 	}
@@ -714,17 +715,17 @@ int dev_manager_mirror_percent(struct de
 {
 	char *name;
 	const char *dlid;
-	const char *suffix = (lv_is_origin(lv)) ? "real" : NULL;
+	const char *layer = (lv_is_origin(lv)) ? "real" : NULL;
 
 	/*
 	 * Build a name for the top layer.
 	 */
-	if (!(name = build_dm_name(dm->mem, lv->vg->name, lv->name, suffix)))
+	if (!(name = build_dm_name(dm->mem, lv->vg->name, lv->name, layer)))
 		return_0;
 
 	/* FIXME dm_pool_free ? */
 
-	if (!(dlid = build_dm_uuid(dm->mem, lv->lvid.s, suffix))) {
+	if (!(dlid = build_dm_uuid(dm->mem, lv->lvid.s, layer))) {
 		log_error("dlid build failed for %s", lv->name);
 		return 0;
 	}
@@ -1014,16 +1015,16 @@ static int _add_partial_replicator_to_dt
 /*
  * Add LV and any known dependencies
  */
-static int _add_lv_to_dtree(struct dev_manager *dm, struct dm_tree *dtree, struct logical_volume *lv)
+static int _add_lv_to_dtree(struct dev_manager *dm, struct dm_tree *dtree, struct logical_volume *lv, unsigned origin_only)
 {
-	if (!_add_dev_to_dtree(dm, dtree, lv, NULL))
+	if (!origin_only && !_add_dev_to_dtree(dm, dtree, lv, NULL))
 		return_0;
 
 	/* FIXME Can we avoid doing this every time? */
 	if (!_add_dev_to_dtree(dm, dtree, lv, "real"))
 		return_0;
 
-	if (!_add_dev_to_dtree(dm, dtree, lv, "cow"))
+	if (!origin_only && !_add_dev_to_dtree(dm, dtree, lv, "cow"))
 		return_0;
 
 	if ((lv->status & MIRRORED) && first_seg(lv)->log_lv &&
@@ -1038,7 +1039,7 @@ static int _add_lv_to_dtree(struct dev_m
 	return 1;
 }
 
-static struct dm_tree *_create_partial_dtree(struct dev_manager *dm, struct logical_volume *lv)
+static struct dm_tree *_create_partial_dtree(struct dev_manager *dm, struct logical_volume *lv, unsigned origin_only)
 {
 	struct dm_tree *dtree;
 	struct dm_list *snh, *snht;
@@ -1050,19 +1051,20 @@ static struct dm_tree *_create_partial_d
 		return NULL;
 	}
 
-	if (!_add_lv_to_dtree(dm, dtree, lv))
+	if (!_add_lv_to_dtree(dm, dtree, lv, origin_only))
 		goto_bad;
 
 	/* Add any snapshots of this LV */
-	dm_list_iterate_safe(snh, snht, &lv->snapshot_segs)
-		if (!_add_lv_to_dtree(dm, dtree, dm_list_struct_base(snh, struct lv_segment, origin_list)->cow))
-			goto_bad;
+	if (!origin_only)
+		dm_list_iterate_safe(snh, snht, &lv->snapshot_segs)
+			if (!_add_lv_to_dtree(dm, dtree, dm_list_struct_base(snh, struct lv_segment, origin_list)->cow, 0))
+				goto_bad;
 
 	/* Add any LVs used by segments in this LV */
 	dm_list_iterate_items(seg, &lv->segments)
 		for (s = 0; s < seg->area_count; s++)
 			if (seg_type(seg, s) == AREA_LV && seg_lv(seg, s)) {
-				if (!_add_lv_to_dtree(dm, dtree, seg_lv(seg, s)))
+				if (!_add_lv_to_dtree(dm, dtree, seg_lv(seg, s), 0))
 					goto_bad;
 			}
 
@@ -1586,7 +1588,7 @@ static int _remove_lv_symlinks(struct de
 	return r;
 }
 
-static int _clean_tree(struct dev_manager *dm, struct dm_tree_node *root)
+static int _clean_tree(struct dev_manager *dm, struct dm_tree_node *root, char *non_toplevel_tree_dlid)
 {
 	void *handle = NULL;
 	struct dm_tree_node *child;
@@ -1610,6 +1612,10 @@ static int _clean_tree(struct dev_manage
 		if (!*layer)
 			continue;
 
+		/* If operation was performed on a partial tree, don't remove it */
+		if (non_toplevel_tree_dlid && !strcmp(non_toplevel_tree_dlid, uuid))
+			continue;
+
 		dm_tree_set_cookie(root, 0);
 		r = dm_tree_deactivate_children(root, uuid, strlen(uuid));
 		if (!dm_udev_wait(dm_tree_get_cookie(root)))
@@ -1622,14 +1628,15 @@ static int _clean_tree(struct dev_manage
 	return 1;
 }
 
-static int _tree_action(struct dev_manager *dm, struct logical_volume *lv, action_t action)
+static int _tree_action(struct dev_manager *dm, struct logical_volume *lv,
+			unsigned origin_only, action_t action)
 {
 	struct dm_tree *dtree;
 	struct dm_tree_node *root;
 	char *dlid;
 	int r = 0;
 
-	if (!(dtree = _create_partial_dtree(dm, lv)))
+	if (!(dtree = _create_partial_dtree(dm, lv, origin_only)))
 		return_0;
 
 	if (!(root = dm_tree_find_node(dtree, 0, 0))) {
@@ -1637,14 +1644,14 @@ static int _tree_action(struct dev_manag
 		goto out;
 	}
 
-	if (!(dlid = build_dm_uuid(dm->mem, lv->lvid.s, NULL)))
+	if (!(dlid = build_dm_uuid(dm->mem, lv->lvid.s, origin_only ? "real" : NULL)))
 		goto_out;
 
 	/* Only process nodes with uuid of "LVM-" plus VG id. */
 	switch(action) {
 	case CLEAN:
 		/* Deactivate any unused non-toplevel nodes */
-		if (!_clean_tree(dm, root))
+		if (!_clean_tree(dm, root, origin_only ? dlid : NULL))
 			goto_out;
 		break;
 	case DEACTIVATE:
@@ -1669,7 +1676,7 @@ static int _tree_action(struct dev_manag
 	case PRELOAD:
 	case ACTIVATE:
 		/* Add all required new devices to tree */
-		if (!_add_new_lv_to_dtree(dm, dtree, lv, NULL))
+		if (!_add_new_lv_to_dtree(dm, dtree, lv, origin_only ? "real" : NULL))
 			goto_out;
 
 		/* Preload any devices required before any suspensions */
@@ -1710,22 +1717,24 @@ out:
 	return r;
 }
 
-int dev_manager_activate(struct dev_manager *dm, struct logical_volume *lv)
+/* origin_only may only be set if we are resuming (not activating) an origin LV */
+int dev_manager_activate(struct dev_manager *dm, struct logical_volume *lv, unsigned origin_only)
 {
-	if (!_tree_action(dm, lv, ACTIVATE))
+	if (!_tree_action(dm, lv, origin_only, ACTIVATE))
 		return_0;
 
-	return _tree_action(dm, lv, CLEAN);
+	return _tree_action(dm, lv, origin_only, CLEAN);
 }
 
+/* origin_only may only be set if we are resuming (not activating) an origin LV */
 int dev_manager_preload(struct dev_manager *dm, struct logical_volume *lv,
-			int *flush_required)
+			unsigned origin_only, int *flush_required)
 {
 	/* FIXME Update the pvmove implementation! */
 	if ((lv->status & PVMOVE) || (lv->status & LOCKED))
 		return 1;
 
-	if (!_tree_action(dm, lv, PRELOAD))
+	if (!_tree_action(dm, lv, origin_only, PRELOAD))
 		return 0;
 
 	*flush_required = dm->flush_required;
@@ -1737,17 +1746,17 @@ int dev_manager_deactivate(struct dev_ma
 {
 	int r;
 
-	r = _tree_action(dm, lv, DEACTIVATE);
+	r = _tree_action(dm, lv, 0, DEACTIVATE);
 
 	return r;
 }
 
 int dev_manager_suspend(struct dev_manager *dm, struct logical_volume *lv,
-			int lockfs, int flush_required)
+			unsigned origin_only, int lockfs, int flush_required)
 {
 	dm->flush_required = flush_required;
 
-	return _tree_action(dm, lv, lockfs ? SUSPEND_WITH_LOCKFS : SUSPEND);
+	return _tree_action(dm, lv, origin_only, lockfs ? SUSPEND_WITH_LOCKFS : SUSPEND);
 }
 
 /*
--- LVM2.2.02.72-RHEL6-edited2/lib/activate/dev_manager.h	2010-05-24 16:32:20.000000000 +0100
+++ LVM2.2.02.72-RHEL6-edited3/lib/activate/dev_manager.h	2010-08-18 03:40:48.000000000 +0100
@@ -41,6 +41,7 @@ void dev_manager_exit(void);
  * unsuspended until the snapshot is also created.)
  */
 int dev_manager_info(struct dm_pool *mem, const struct logical_volume *lv,
+		     const char *layer,
 		     int with_open_count, int with_read_ahead,
 		     struct dm_info *info, uint32_t *read_ahead);
 int dev_manager_snapshot_percent(struct dev_manager *dm,
@@ -52,10 +53,10 @@ int dev_manager_mirror_percent(struct de
 			       float *percent, percent_range_t *percent_range,
 			       uint32_t *event_nr);
 int dev_manager_suspend(struct dev_manager *dm, struct logical_volume *lv,
-			int lockfs, int flush_required);
-int dev_manager_activate(struct dev_manager *dm, struct logical_volume *lv);
+			unsigned origin_only, int lockfs, int flush_required);
+int dev_manager_activate(struct dev_manager *dm, struct logical_volume *lv, unsigned origin_only);
 int dev_manager_preload(struct dev_manager *dm, struct logical_volume *lv,
-			int *flush_required);
+			unsigned origin_only, int *flush_required);
 int dev_manager_deactivate(struct dev_manager *dm, struct logical_volume *lv);
 int dev_manager_transient(struct dev_manager *dm, struct logical_volume *lv);
 
--- LVM2.2.02.72-RHEL6-edited2/lib/display/display.c	2010-07-09 16:34:42.000000000 +0100
+++ LVM2.2.02.72-RHEL6-edited3/lib/display/display.c	2010-08-18 03:40:48.000000000 +0100
@@ -452,7 +452,7 @@ void lvdisplay_colons(const struct logic
 {
 	int inkernel;
 	struct lvinfo info;
-	inkernel = lv_info(lv->vg->cmd, lv, &info, 1, 0) && info.exists;
+	inkernel = lv_info(lv->vg->cmd, lv, 0, &info, 1, 0) && info.exists;
 
 	log_print("%s%s/%s:%s:%" PRIu64 ":%d:-1:%d:%" PRIu64 ":%d:-1:%d:%d:%d:%d",
 		  lv->vg->cmd->dev_dir,
@@ -481,7 +481,7 @@ int lvdisplay_full(struct cmd_context *c
 	if (!id_write_format(&lv->lvid.id[1], uuid, sizeof(uuid)))
 		return_0;
 
-	inkernel = lv_info(cmd, lv, &info, 1, 1) && info.exists;
+	inkernel = lv_info(cmd, lv, 0, &info, 1, 1) && info.exists;
 
 	log_print("--- Logical volume ---");
 
--- LVM2.2.02.72-RHEL6-edited2/lib/locking/file_locking.c	2010-07-09 16:34:45.000000000 +0100
+++ LVM2.2.02.72-RHEL6-edited3/lib/locking/file_locking.c	2010-08-18 03:40:48.000000000 +0100
@@ -254,6 +254,7 @@ static int _file_lock_resource(struct cm
 			       uint32_t flags)
 {
 	char lockfile[PATH_MAX];
+	unsigned origin_only = (flags & LCK_ORIGIN_ONLY) ? 1 : 0;
 
 	switch (flags & LCK_SCOPE_MASK) {
 	case LCK_VG:
@@ -278,8 +279,8 @@ static int _file_lock_resource(struct cm
 	case LCK_LV:
 		switch (flags & LCK_TYPE_MASK) {
 		case LCK_UNLOCK:
-			log_very_verbose("Unlocking LV %s", resource);
-			if (!lv_resume_if_active(cmd, resource))
+			log_very_verbose("Unlocking LV %s%s", resource, origin_only ? " without snapshots" : "");
+			if (!lv_resume_if_active(cmd, resource, origin_only))
 				return 0;
 			break;
 		case LCK_NULL:
@@ -296,8 +297,8 @@ static int _file_lock_resource(struct cm
 			log_very_verbose("Locking LV %s (PR) - ignored", resource);
 			break;
 		case LCK_WRITE:
-			log_very_verbose("Locking LV %s (W)", resource);
-			if (!lv_suspend_if_active(cmd, resource))
+			log_very_verbose("Locking LV %s (W)%s", resource, origin_only ? " without snapshots" : "");
+			if (!lv_suspend_if_active(cmd, resource, origin_only))
 				return 0;
 			break;
 		case LCK_EXCL:
--- LVM2.2.02.72-RHEL6-edited2/lib/locking/locking.h	2010-06-17 13:48:55.000000000 +0100
+++ LVM2.2.02.72-RHEL6-edited3/lib/locking/locking.h	2010-08-18 03:40:48.000000000 +0100
@@ -93,6 +93,7 @@ int check_lvm1_vg_inactive(struct cmd_co
 #define LCK_LOCAL	0x00000040U	/* Don't propagate to other nodes */
 #define LCK_CLUSTER_VG	0x00000080U	/* VG is clustered */
 #define LCK_CACHE	0x00000100U	/* Operation on cache only using P_ lock */
+#define LCK_ORIGIN_ONLY	0x00000200U	/* Operation should bypass any snapshots */
 
 /*
  * Additional lock bits for cluster communication
@@ -148,7 +149,9 @@ int check_lvm1_vg_inactive(struct cmd_co
 	} while (0)
 
 #define resume_lv(cmd, lv)	lock_lv_vol(cmd, lv, LCK_LV_RESUME)
+#define resume_lv_origin(cmd, lv)	lock_lv_vol(cmd, lv, LCK_LV_RESUME | LCK_ORIGIN_ONLY)
 #define suspend_lv(cmd, lv)	lock_lv_vol(cmd, lv, LCK_LV_SUSPEND | LCK_HOLD)
+#define suspend_lv_origin(cmd, lv)	lock_lv_vol(cmd, lv, LCK_LV_SUSPEND | LCK_HOLD | LCK_ORIGIN_ONLY)
 #define deactivate_lv(cmd, lv)	lock_lv_vol(cmd, lv, LCK_LV_DEACTIVATE)
 #define activate_lv(cmd, lv)	lock_lv_vol(cmd, lv, LCK_LV_ACTIVATE | LCK_HOLD)
 #define activate_lv_excl(cmd, lv)	\
--- LVM2.2.02.72-RHEL6-edited2/lib/locking/no_locking.c	2010-07-09 16:34:45.000000000 +0100
+++ LVM2.2.02.72-RHEL6-edited3/lib/locking/no_locking.c	2010-08-18 03:40:48.000000000 +0100
@@ -44,11 +44,11 @@ static int _no_lock_resource(struct cmd_
 		case LCK_NULL:
 			return lv_deactivate(cmd, resource);
 		case LCK_UNLOCK:
-			return lv_resume_if_active(cmd, resource);
+			return lv_resume_if_active(cmd, resource, (flags & LCK_ORIGIN_ONLY) ? 1: 0);
 		case LCK_READ:
 			return lv_activate_with_filter(cmd, resource, 0);
 		case LCK_WRITE:
-			return lv_suspend_if_active(cmd, resource);
+			return lv_suspend_if_active(cmd, resource, (flags & LCK_ORIGIN_ONLY) ? 1 : 0);
 		case LCK_EXCL:
 			return lv_activate_with_filter(cmd, resource, 1);
 		default:
--- LVM2.2.02.72-RHEL6-edited2/lib/metadata/lv_manip.c	2010-07-09 16:34:45.000000000 +0100
+++ LVM2.2.02.72-RHEL6-edited3/lib/metadata/lv_manip.c	2010-08-18 03:40:48.000000000 +0100
@@ -2237,7 +2237,7 @@ int lv_remove_single(struct cmd_context 
 
 	/* FIXME Ensure not referred to by another existing LVs */
 
-	if (lv_info(cmd, lv, &info, 1, 0)) {
+	if (lv_info(cmd, lv, 0, &info, 1, 0)) {
 		if (info.open_count) {
 			log_error("Can't remove open logical volume \"%s\"",
 				  lv->name);
@@ -3109,7 +3109,7 @@ int lv_create_single(struct volume_group
 				return 0;
 			}
 
-			if (!lv_info(cmd, org, &info, 0, 0)) {
+			if (!lv_info(cmd, org, 0, &info, 0, 0)) {
 				log_error("Check for existence of snapshot "
 					  "origin '%s' failed.", org->name);
 				return 0;
--- LVM2.2.02.72-RHEL6-edited2/lib/metadata/mirror.c	2010-08-18 01:45:59.000000000 +0100
+++ LVM2.2.02.72-RHEL6-edited3/lib/metadata/mirror.c	2010-08-18 03:40:48.000000000 +0100
@@ -292,14 +292,14 @@ static int _init_mirror_log(struct cmd_c
 	}
 
 	/* If the LV is active, deactivate it first. */
-	if (lv_info(cmd, log_lv, &info, 0, 0) && info.exists) {
+	if (lv_info(cmd, log_lv, 0, &info, 0, 0) && info.exists) {
 		(void)deactivate_lv(cmd, log_lv);
 		/*
 		 * FIXME: workaround to fail early
 		 * Ensure that log is really deactivated because deactivate_lv
 		 * on cluster do not fail if there is log_lv with different UUID.
 		 */
-		if (lv_info(cmd, log_lv, &info, 0, 0) && info.exists) {
+		if (lv_info(cmd, log_lv, 0, &info, 0, 0) && info.exists) {
 			log_error("Aborting. Unable to deactivate mirror log.");
 			goto revert_new_lv;
 		}
@@ -969,7 +969,7 @@ static int _remove_mirror_images(struct 
 		return 0;
 	}
 
-	if (!suspend_lv(mirrored_seg->lv->vg->cmd, mirrored_seg->lv)) {
+	if (!suspend_lv_origin(mirrored_seg->lv->vg->cmd, mirrored_seg->lv)) {
 		log_error("Failed to lock %s", mirrored_seg->lv->name);
 		vg_revert(mirrored_seg->lv->vg);
 		return 0;
@@ -1004,7 +1004,7 @@ static int _remove_mirror_images(struct 
 		return 0;
 	}
 
-	if (!resume_lv(mirrored_seg->lv->vg->cmd, mirrored_seg->lv)) {
+	if (!resume_lv_origin(mirrored_seg->lv->vg->cmd, mirrored_seg->lv)) {
 		log_error("Problem reactivating %s", mirrored_seg->lv->name);
 		return 0;
 	}
@@ -1622,7 +1622,7 @@ int remove_mirror_log(struct cmd_context
 	}
 
 	/* Had disk log, switch to core. */
-	if (lv_info(cmd, lv, &info, 0, 0) && info.exists) {
+	if (lv_info(cmd, lv, 0, &info, 0, 0) && info.exists) {
 		if (!lv_mirror_percent(cmd, lv, 0, &sync_percent,
 				       &percent_range, NULL)) {
 			log_error("Unable to determine mirror sync status.");
@@ -1822,7 +1822,7 @@ int add_mirror_log(struct cmd_context *c
 	 * on remote nodes (even though it is inactive on this node)
 	 */
 	if (vg_is_clustered(lv->vg) &&
-	    !(lv_info(cmd, lv, &info, 0, 0) && info.exists)) {
+	    !(lv_info(cmd, lv, 0, &info, 0, 0) && info.exists)) {
 		log_error("Unable to convert the log of inactive "
 			  "cluster mirror %s", lv->name);
 		return 0;
--- LVM2.2.02.72-RHEL6-edited2/lib/mirror/mirrored.c	2010-08-18 02:48:28.000000000 +0100
+++ LVM2.2.02.72-RHEL6-edited3/lib/mirror/mirrored.c	2010-08-18 03:40:48.000000000 +0100
@@ -300,7 +300,7 @@ static int _mirrored_transient_status(st
 	if (!strcmp(log_args[0], "disk")) {
 		char buf[32];
 		log = first_seg(lv)->log_lv;
-		lv_info(lv->vg->cmd, log, &info, 0, 0);
+		lv_info(lv->vg->cmd, log, 0, &info, 0, 0);
 		log_debug("Found mirror log at %d:%d", info.major, info.minor);
 		sprintf(buf, "%d:%d", info.major, info.minor);
 		if (strcmp(buf, log_args[1])) {
@@ -320,7 +320,7 @@ static int _mirrored_transient_status(st
 
 	for (i = 0; i < seg->area_count; ++i) {
 		char buf[32];
-		lv_info(lv->vg->cmd, seg_lv(seg, i), &info, 0, 0);
+		lv_info(lv->vg->cmd, seg_lv(seg, i), 0, &info, 0, 0);
 		log_debug("Found mirror leg at %d:%d", info.major, info.minor);
 		sprintf(buf, "%d:%d", info.major, info.minor);
 		for (j = 0; j < num_devs; ++j) {
--- LVM2.2.02.72-RHEL6-edited2/lib/report/report.c	2010-07-09 16:34:46.000000000 +0100
+++ LVM2.2.02.72-RHEL6-edited3/lib/report/report.c	2010-08-18 03:40:48.000000000 +0100
@@ -245,7 +245,7 @@ static int _lvkmaj_disp(struct dm_report
 	const struct logical_volume *lv = (const struct logical_volume *) data;
 	struct lvinfo info;
 
-	if (lv_info(lv->vg->cmd, lv, &info, 0, 0) && info.exists)
+	if (lv_info(lv->vg->cmd, lv, 0, &info, 0, 0) && info.exists)
 		return dm_report_field_int(rh, field, &info.major);
 
 	return dm_report_field_int32(rh, field, &_minusone32);
@@ -258,7 +258,7 @@ static int _lvkmin_disp(struct dm_report
 	const struct logical_volume *lv = (const struct logical_volume *) data;
 	struct lvinfo info;
 
-	if (lv_info(lv->vg->cmd, lv, &info, 0, 0) && info.exists)
+	if (lv_info(lv->vg->cmd, lv, 0, &info, 0, 0) && info.exists)
 		return dm_report_field_int(rh, field, &info.minor);
 
 	return dm_report_field_int32(rh, field, &_minusone32);
@@ -351,7 +351,7 @@ static int _lvstatus_disp(struct dm_repo
 	else
 		repstr[3] = '-';
 
-	if (lv_info(lv->vg->cmd, lv, &info, 1, 0) && info.exists) {
+	if (lv_info(lv->vg->cmd, lv, 0, &info, 1, 0) && info.exists) {
 		if (info.suspended)
 			repstr[4] = 's';	/* Suspended */
 		else if (info.live_table)
@@ -683,7 +683,7 @@ static int _lvkreadahead_disp(struct dm_
 	const struct logical_volume *lv = (const struct logical_volume *) data;
 	struct lvinfo info;
 
-	if (!lv_info(lv->vg->cmd, lv, &info, 0, 1) || !info.exists)
+	if (!lv_info(lv->vg->cmd, lv, 0, &info, 0, 1) || !info.exists)
 		return dm_report_field_int32(rh, field, &_minusone32);
 
 	return _size32_disp(rh, mem, field, &info.read_ahead, private);
@@ -1085,7 +1085,7 @@ static int _snpercent_disp(struct dm_rep
 	}
 
 	if ((!lv_is_cow(lv) && !lv_is_merging_origin(lv)) ||
-	    !lv_info(lv->vg->cmd, lv, &info, 0, 0) || !info.exists) {
+	    !lv_info(lv->vg->cmd, lv, 0, &info, 0, 0) || !info.exists) {
 		*sortval = UINT64_C(0);
 		dm_report_field_set_value(field, "", sortval);
 		return 1;
--- LVM2.2.02.72-RHEL6-edited2/liblvm/lvm_lv.c	2010-07-09 17:57:34.000000000 +0100
+++ LVM2.2.02.72-RHEL6-edited3/liblvm/lvm_lv.c	2010-08-18 03:40:48.000000000 +0100
@@ -57,7 +57,7 @@ const char *lvm_lv_get_name(const lv_t l
 uint64_t lvm_lv_is_active(const lv_t lv)
 {
 	struct lvinfo info;
-	if (lv_info(lv->vg->cmd, lv, &info, 1, 0) &&
+	if (lv_info(lv->vg->cmd, lv, 0, &info, 1, 0) &&
 	    info.exists && info.live_table)
 		return 1;
 	return 0;
@@ -66,7 +66,7 @@ uint64_t lvm_lv_is_active(const lv_t lv)
 uint64_t lvm_lv_is_suspended(const lv_t lv)
 {
 	struct lvinfo info;
-	if (lv_info(lv->vg->cmd, lv, &info, 1, 0) &&
+	if (lv_info(lv->vg->cmd, lv, 0, &info, 1, 0) &&
 	    info.exists && info.suspended)
 		return 1;
 	return 0;
--- LVM2.2.02.72-RHEL6-edited2/tools/lvchange.c	2010-07-09 16:34:48.000000000 +0100
+++ LVM2.2.02.72-RHEL6-edited3/tools/lvchange.c	2010-08-18 03:40:48.000000000 +0100
@@ -37,7 +37,7 @@ static int lvchange_permission(struct cm
 	}
 
 	if ((lv->status & MIRRORED) && (vg_is_clustered(lv->vg)) &&
-	    lv_info(cmd, lv, &info, 0, 0) && info.exists) {
+	    lv_info(cmd, lv, 0, &info, 0, 0) && info.exists) {
 		log_error("Cannot change permissions of mirror \"%s\" "
 			  "while active.", lv->name);
 		return 0;
@@ -86,7 +86,7 @@ static int lvchange_monitoring(struct cm
 {
 	struct lvinfo info;
 
-	if (!lv_info(cmd, lv, &info, 0, 0) || !info.exists) {
+	if (!lv_info(cmd, lv, 0, &info, 0, 0) || !info.exists) {
 		log_error("Logical volume, %s, is not active", lv->name);
 		return 0;
 	}
@@ -96,7 +96,7 @@ static int lvchange_monitoring(struct cm
 		return 1;
 
 	if ((dmeventd_monitor_mode() != DMEVENTD_MONITOR_IGNORE) &&
-	    !monitor_dev_for_events(cmd, lv, dmeventd_monitor_mode()))
+	    !monitor_dev_for_events(cmd, lv, 0, dmeventd_monitor_mode()))
 		stack;
 
 	return 1;
@@ -107,7 +107,7 @@ static int lvchange_background_polling(s
 {
 	struct lvinfo info;
 
-	if (!lv_info(cmd, lv, &info, 0, 0) || !info.exists) {
+	if (!lv_info(cmd, lv, 0, &info, 0, 0) || !info.exists) {
 		log_error("Logical volume, %s, is not active", lv->name);
 		return 0;
 	}
@@ -189,7 +190,7 @@ static int lvchange_resync(struct cmd_co
 		return 0;
 	}
 
-	if (lv_info(cmd, lv, &info, 1, 0)) {
+	if (lv_info(cmd, lv, 0, &info, 1, 0)) {
 		if (info.open_count) {
 			log_error("Can't resync open logical volume \"%s\"",
 				  lv->name);
@@ -446,7 +447,7 @@ static int lvchange_persistent(struct cm
 			log_error("Major number must be specified with -My");
 			return 0;
 		}
-		if (lv_info(cmd, lv, &info, 0, 0) && info.exists)
+		if (lv_info(cmd, lv, 0, &info, 0, 0) && info.exists)
 			active = 1;
 		if (active && !arg_count(cmd, force_ARG) &&
 		    yes_no_prompt("Logical volume %s will be "
--- LVM2.2.02.72-RHEL6-edited2/tools/lvconvert.c	2010-08-18 01:45:59.000000000 +0100
+++ LVM2.2.02.72-RHEL6-edited3/tools/lvconvert.c	2010-08-18 03:40:48.000000000 +0100
@@ -1459,13 +1459,13 @@ static int lvconvert_merge(struct cmd_co
 	 * constructor and DM should prevent appropriate devices from
 	 * being open.
 	 */
-	if (lv_info(cmd, origin, &info, 1, 0)) {
+	if (lv_info(cmd, origin, 0, &info, 1, 0)) {
 		if (info.open_count) {
 			log_error("Can't merge over open origin volume");
 			merge_on_activate = 1;
 		}
 	}
-	if (lv_info(cmd, lv, &info, 1, 0)) {
+	if (lv_info(cmd, lv, 0, &info, 1, 0)) {
 		if (info.open_count) {
 			log_print("Can't merge when snapshot is open");
 			merge_on_activate = 1;
@@ -1627,7 +1627,7 @@ static int poll_logical_volume(struct cm
 {
 	struct lvinfo info;
 
-	if (!lv_info(cmd, lv, &info, 1, 0) || !info.exists) {
+	if (!lv_info(cmd, lv, 0, &info, 1, 0) || !info.exists) {
 		log_print("Conversion starts after activation.");
 		return ECMD_PROCESSED;
 	}
--- LVM2.2.02.72-RHEL6-edited2/tools/lvresize.c	2010-04-29 02:38:14.000000000 +0100
+++ LVM2.2.02.72-RHEL6-edited3/tools/lvresize.c	2010-08-18 03:40:48.000000000 +0100
@@ -90,7 +90,7 @@ static int _request_confirmation(struct 
 
 	memset(&info, 0, sizeof(info));
 
-	if (!lv_info(cmd, lv, &info, 1, 0) && driver_version(NULL, 0)) {
+	if (!lv_info(cmd, lv, 0, &info, 1, 0) && driver_version(NULL, 0)) {
 		log_error("lv_info failed: aborting");
 		return 0;
 	}
@@ -572,7 +572,7 @@ static int _lvresize(struct cmd_context 
 
 		memset(&info, 0, sizeof(info));
 
-		if (lv_info(cmd, lv, &info, 0, 0) && info.exists) {
+		if (lv_info(cmd, lv, 0, &info, 0, 0) && info.exists) {
 			log_error("Snapshot origin volumes can be resized "
 				  "only while inactive: try lvchange -an");
 			return ECMD_FAILED;
--- LVM2.2.02.72-RHEL6-edited2/tools/lvscan.c	2010-07-09 16:34:48.000000000 +0100
+++ LVM2.2.02.72-RHEL6-edited3/tools/lvscan.c	2010-08-18 03:40:48.000000000 +0100
@@ -31,7 +31,7 @@ static int lvscan_single(struct cmd_cont
 	if (!arg_count(cmd, all_ARG) && !lv_is_visible(lv))
 		return ECMD_PROCESSED;
 
-	inkernel = lv_info(cmd, lv, &info, 1, 0) && info.exists;
+	inkernel = lv_info(cmd, lv, 0, &info, 1, 0) && info.exists;
 	if (lv_is_origin(lv)) {
 		dm_list_iterate_items_gen(snap_seg, &lv->snapshot_segs,
 				       origin_list) {
--- LVM2.2.02.72-RHEL6-edited2/tools/vgchange.c	2010-07-26 20:03:29.000000000 +0100
+++ LVM2.2.02.72-RHEL6-edited3/tools/vgchange.c	2010-08-18 03:40:48.000000000 +0100
@@ -27,7 +27,7 @@ static int _monitor_lvs_in_vg(struct cmd
 	dm_list_iterate_items(lvl, &vg->lvs) {
 		lv = lvl->lv;
 
-		if (!lv_info(cmd, lv, &info, 0, 0))
+		if (!lv_info(cmd, lv, 0, &info, 0, 0))
 			lv_active = 0;
 		else
 			lv_active = info.exists;
@@ -38,7 +38,7 @@ static int _monitor_lvs_in_vg(struct cmd
 		if ((lv->status & PVMOVE) || !lv_active)
 			continue;
 
-		if (!monitor_dev_for_events(cmd, lv, reg)) {
+		if (!monitor_dev_for_events(cmd, lv, 0, reg)) {
 			continue;
 		} else
 			count++;
@@ -63,7 +63,7 @@ static int _poll_lvs_in_vg(struct cmd_co
 	dm_list_iterate_items(lvl, &vg->lvs) {
 		lv = lvl->lv;
 
-		if (!lv_info(cmd, lv, &info, 0, 0))
+		if (!lv_info(cmd, lv, 0, &info, 0, 0))
 			lv_active = 0;
 		else
 			lv_active = info.exists;
--- LVM2.2.02.72-RHEL6-edited2/tools/vgconvert.c	2010-07-09 16:34:48.000000000 +0100
+++ LVM2.2.02.72-RHEL6-edited3/tools/vgconvert.c	2010-08-18 03:40:48.000000000 +0100
@@ -98,7 +98,7 @@ static int vgconvert_single(struct cmd_c
 				continue;
 			if (lvnum_from_lvid(&lv->lvid) < MAX_RESTRICTED_LVS)
 				continue;
-			if (lv_info(cmd, lv, &info, 0, 0) && info.exists) {
+			if (lv_info(cmd, lv, 0, &info, 0, 0) && info.exists) {
 				log_error("Logical volume %s must be "
 					  "deactivated before conversion.",
 					   lv->name);
--- LVM2.2.02.72-RHEL6-edited2/tools/vgreduce.c	2010-07-09 16:34:48.000000000 +0100
+++ LVM2.2.02.72-RHEL6-edited3/tools/vgreduce.c	2010-08-18 03:40:48.000000000 +0100
@@ -108,7 +108,7 @@ static int _remove_lv(struct cmd_context
 	 * the mirrored LV also should be cleaned up.
 	 * Clean-up is currently done by caller (_make_vg_consistent()).
 	 */
-	if ((lv_info(cmd, lv, &info, 0, 0) && info.exists) ||
+	if ((lv_info(cmd, lv, 0, &info, 0, 0) && info.exists) ||
 	    find_mirror_seg(first_seg(lv))) {
 		if (!replace_lv_with_error_segment(lv))
 			return_0;
--- LVM2.2.02.72-RHEL6-edited2/WHATS_NEW	2010-08-18 02:48:46.000000000 +0100
+++ LVM2.2.02.72-RHEL6-edited3/WHATS_NEW	2010-08-18 03:40:48.000000000 +0100
@@ -1,5 +1,8 @@
 Version 2.02.73 -
 ================================
+  Ignore snapshots when performing mirror recovery beneath an origin.
+  Add suspend_lv_origin and resume_lv_origin using LCK_ORIGIN_ONLY.
+  Allow internal suspend and resume of origin without its snapshots.
   Fix dev_manager_transient to access -real device not snapshot-origin.
   Monitor origin -real device below snapshot instead of overlay device.
   Change default alignment of pe_start to 1MB.
